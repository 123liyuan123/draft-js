(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{183:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"rightToc",(function(){return r})),n.d(t,"default",(function(){return c}));n(210),n(211),n(207),n(212),n(213),n(214);var a=n(208);function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var o={id:"advanced-topics-editorstate-race-conditions",title:"EditorState Race Conditions"},r=[{value:"Best Practices",id:"best-practices",children:[]}],s={rightToc:r},l="wrapper";function c(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,["components"]);return Object(a.b)(l,i({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Draft ",Object(a.b)("inlineCode",{parentName:"p"},"Editor")," is a ",Object(a.b)("em",{parentName:"p"},"controlled input")," component (you can read about this in detail in the ",Object(a.b)("a",i({parentName:"p"},{href:"/docs/quickstart-api-basics"}),"API Basics")," section), meaning that changes made to the ",Object(a.b)("inlineCode",{parentName:"p"},"Editor")," state are propagated upwards through ",Object(a.b)("inlineCode",{parentName:"p"},"onChange")," and it's up to the app to feed it back to the ",Object(a.b)("inlineCode",{parentName:"p"},"Editor")," component."),Object(a.b)("p",null,"This cycle usually looks like:"),Object(a.b)("pre",null,Object(a.b)("code",i({parentName:"pre"},{className:"language-js"}),'...\nthis.onChange = function(editorState) {\n  this.setState({editorState: editorState});\n}\n...\n<Editor\n  editorState={this.state.editorState}\n  onChange={this.onChange}\n  placeholder="Enter some text..."\n/>\n')),Object(a.b)("p",null,"Different browser events can trigger the ",Object(a.b)("inlineCode",{parentName:"p"},"Editor")," to create a new state and call ",Object(a.b)("inlineCode",{parentName:"p"},"onChange"),". For instance, when the user pastes text into it, Draft parses the new content and creates the necessary data structure to represent it."),Object(a.b)("p",null,"This cycle works great, however, it is an asynchronous operation because of the ",Object(a.b)("inlineCode",{parentName:"p"},"setState")," call. This introduces a delay between setting the state and rendering the ",Object(a.b)("inlineCode",{parentName:"p"},"Editor")," with the new state. During this time period other JS code can be executed."),Object(a.b)("p",null,Object(a.b)("img",i({parentName:"p"},{src:"/img/editorstate-race-condition-1-handler.png",alt:"Race condition diagram 1"}))),Object(a.b)("p",null,"Non-atomic operations like this can potentially introduce race conditions.\nHere's an example: Suppose you want to remove all the text styles that come from the paste. This can be implemented by listening to the onPaste event and removing all styles from the ",Object(a.b)("inlineCode",{parentName:"p"},"EditorState"),":"),Object(a.b)("pre",null,Object(a.b)("code",i({parentName:"pre"},{className:"language-js"}),"this.onPaste = function() {\n  this.setState({\n    editorState: removeEditorStyles(this.state.editorState),\n  });\n};\n")),Object(a.b)("p",null,"However, this won't work as expected. You now have two event handlers that set a new ",Object(a.b)("inlineCode",{parentName:"p"},"EditorState")," in the exact same browser event. Since the event handlers will run one after the other only the last ",Object(a.b)("inlineCode",{parentName:"p"},"setState")," will prevail. Here's how it looks like in the JS timeline:"),Object(a.b)("p",null,Object(a.b)("img",i({parentName:"p"},{src:"/img/editorstate-race-condition-2-handlers.png",alt:"Race condition diagram 2"}))),Object(a.b)("p",null,"As you can see, since ",Object(a.b)("inlineCode",{parentName:"p"},"setState")," is an asynchronous operation, the second ",Object(a.b)("inlineCode",{parentName:"p"},"setState")," will override whatever it was set on the first one making the ",Object(a.b)("inlineCode",{parentName:"p"},"Editor")," lose all the contents from the pasted text."),Object(a.b)("p",null,"You can observe and explore the race condition in ",Object(a.b)("a",i({parentName:"p"},{href:"https://jsfiddle.net/qecccw3r/"}),"this running example"),". The example also has logging to highlight the JS timeline so make sure to open the developer tools."),Object(a.b)("p",null,"As a rule of thumb avoid having different event handlers for the same event that manipulate the ",Object(a.b)("inlineCode",{parentName:"p"},"EditorState"),". Using setTimeout to run ",Object(a.b)("inlineCode",{parentName:"p"},"setState")," might also land you in the same situation.\nAnytime you feel you're \u201closing state\u201d make sure you're not overriding it before the ",Object(a.b)("inlineCode",{parentName:"p"},"Editor")," re-rendering."),Object(a.b)("h2",{id:"best-practices"},"Best Practices"),Object(a.b)("p",null,"Now that you understand the problem, what can you do to avoid it? In general be mindful of where you're getting the ",Object(a.b)("inlineCode",{parentName:"p"},"EditorState")," from. If you're using a local one (stored in ",Object(a.b)("inlineCode",{parentName:"p"},"this.state"),") then there's the potential for it to not be up to date.\nTo minimize this problem Draft offers the latest ",Object(a.b)("inlineCode",{parentName:"p"},"EditorState")," instance in most of its callback functions. In your code you should use the provided ",Object(a.b)("inlineCode",{parentName:"p"},"EditorState")," instead of your local one to make sure you're basing your changes on the latest one.\nHere's a list of supported callbacks on the ",Object(a.b)("inlineCode",{parentName:"p"},"Editor"),":"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"handleReturn(event, editorState)")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"handleKeyCommand(command, editorState)")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"handleBeforeInput(chars, editorState)")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"handlePastedText(text, html, editorState)"))),Object(a.b)("p",null,"The paste example can then be re-written in a race condition free way by using these methods:"),Object(a.b)("pre",null,Object(a.b)("code",i({parentName:"pre"},{className:"language-js"}),'this.handlePastedText = (text, styles, editorState) => {\n  this.setState({\n    editorState: removeEditorStyles(text, editorState),\n  });\n};\n//...\n<Editor\n  editorState={this.state.editorState}\n  onChange={this.onChange}\n  handlePastedText={this.handlePastedText}\n  placeholder="Enter some text..."\n/>;\n')),Object(a.b)("p",null,"With ",Object(a.b)("inlineCode",{parentName:"p"},"handlePastedText")," you can implement the paste behavior by yourself."),Object(a.b)("p",null,"NOTE: If you need to have this behavior in your Editor, you can achieve it by setting the ",Object(a.b)("inlineCode",{parentName:"p"},"Editor"),"'s ",Object(a.b)("inlineCode",{parentName:"p"},"stripPastedStyles")," property to ",Object(a.b)("inlineCode",{parentName:"p"},"true"),"."))}c.isMDXComponent=!0}}]);